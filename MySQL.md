# MySQL
## 数据库事务

### 一、定义

**事务（transaction)：**是访问并可能操作各种数据项的**一个数据库操作序列**。这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。

事务由事务开始与事务结束之间执行的**全部**数据库操作组成（数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。）。一个典型的数据库事务如下所示：

```sql
BEGIN TRANSACTION  //事务开始
SQL1
SQL2
COMMIT/ROLLBACK   //事务提交或回滚
```



### 二、ACID特性

事务有ACID四大特性：

1. **原子性**(Atomicity):事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。

2. **一致性**(Consistency):事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。

   一致性状态是指:

    1）系统的状态满足数据的完整性约束。

   ​		数据完整性约束指的是为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。

   ​       数据完整性约束是一组完整性规则的集合。规则包含：实体完整性、参照完整性、用户定义完整性。三者都满足即满足了数据完整性约束。

    2）系统的状态反应数据库本应描述的**现实世界的真实状态**，比如转账前后两个账户的金额总和应该保持不变。

3. **隔离性**(Isolation):多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

4. **持久性**(Durability):事务一旦提交，它对数据库的修改应该永久保存在数据库中。



举例：

用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：

1、从A账号中把余额读出来（500）。
2、对A账号做减法操作（500-100）。
3、把结果写回A账号中（400）。
4、从B账号中把余额读出来（500）。
5、对B账号做加法操作（500+100）。
6、把结果写回B账号中（600）。

原子性：保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。

一致性：在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。

隔离性：在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。

持久性：一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）



在事务的ACID特性中,C即**一致性是事务的根本追求**,而对数据一致性的破坏主要来自两个方面：（问题：怎么保证事务的一致性？）

1. 事务的并发执行
2. 事务故障或系统故障

数据库系统是通过**并发控制技术和日志恢复技术**来避免这种情况发生的。

**并发控制技术**：保证了事务的**隔离性**，使数据库的一致性状态不会因为并发执行的操作被破坏。
**日志恢复技术**：保证了事务的**原子性**，使**一致性**状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的**持久性**。

<img src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103102223-1059881337.png" alt="img" style="zoom:50%;" />



[参考1](https://www.cnblogs.com/takumicx/p/9998844.html)

[参考2](http://www.hollischuang.com/archives/898)



### 三、事务的隔离级别

**如果不考虑隔离性，事务并发访问时可能会出现3种问题：脏读、不可重复读、幻读**



 *注：事务的**提交**，即在事务成功执行后提交结束事务； 事务的**回滚**，即在事务执行过程中某个操作出现问题，恢复到事务执行之前的那个一致性状态。*

(1) **脏读**：A事务读取到了B事务**尚未提交**的数据。事务A读取了B更新尚未提交的内容，B事务回滚，导致A读取的内容错误。

<img src="https://img-blog.csdnimg.cn/20191126115112764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY5NDMz,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />

(2) **不可重复读**：一个事务中两次读取的**数据的内容**不一致。事务A读取一个字段，B更新了这个字段，A再读取一次这个字段，两次读取的结果不同。

<img src="https://img-blog.csdnimg.cn/20191126115405316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY5NDMz,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />



(3) **幻读**：一个事务中两次读取的**数据的数量**不一致。事务A读取一个字段的行数，B插入或删除了某些记录，A再读取这个字段的行数，行数不同了。

<img src="https://img-blog.csdnimg.cn/20191126115528921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY5NDMz,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />

不可重复读和幻读问题十分相似： 不可重复读是并发事务B的**UPDATE操作**对事务A带来的问题，幻读是并发事务B的**INSERT和DELETE**操作对事务A带来的问题。



**四个隔离级别：读未提交、读已提交、可重复读、串行化/序列化**

1. **读未提交（READ UNCOMMITTED）**：在该级别中事务的修改即使没有被提交，对其他事务也是可见的。上述三个问题都不能被解决。
2. **读已提交（READ COMMITTED）** **：多数数据库系统默认的隔离级别（但不是MySQL默认的）**。满足了隔离性的简单定义：一个事务开始时只能"看见"已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。只允许事务A读取事务B已经提交的更新。可以解决脏读问题。
3. **可重复读（REPEATABLE READ）** ：**（MySQL默认的隔离级别）**。A事务读取某个字段，在A事务操作期间，禁止B事务对该字段的**更新**。可以解决不可重复读问题。
4. **串行化（SERIALIZABLE）** ：串行化即舍弃事务的并发处理能力，将所有事务串行执行，这样虽然避免了所有的并发问题，但性能效率实在太低，一般不用。

| 隔离级别 | 解决脏读 | 解决不可重复读 | 解决幻读 |
| -------- | -------- | -------------- | -------- |
| 读未提交 | ×        | ×              | ×        |
| 读已提交 | √        | ×              | ×        |
| 可重复读 | √        | √              | ×        |
| 串行化   | √        | √              | √        |



​        四个隔离级别解决问题程度的递增，是用牺牲数据库的并发性能来得到的，如串行化级别，解决了所有的并发问题，

但却没有任何并发能力。所以需要根据实际业务情况选择合适的隔离级别。 还需要清楚，四个隔离级别只是SQL给出的规范，包括前面所讲的ACID事务的实现，每个数据库存储引擎对这些的实现技术都是不同的，所有引擎都在追求更高的隔离级别下的更高的并发能力。比如**MySQL默认使用的InnoDB引擎，使用MVCC技术在可重复读级别下，可以解决幻读问题。**

[参考](https://blog.csdn.net/qq_37969433/article/details/103247421)



### MYSQL **事务日志**

​       **事务日志**可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时，只需要修改其**内存**拷贝，再把该修改行为记录到持久在**硬盘**上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

​      事务日志采用的是**追加**的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。

​      事务日志持久以后，**内存中被修改的数据在后台可以慢慢地刷回到磁盘**。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging）。
​      如果数据的修改**已经记录到事务日志并持久化**，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

MySQL Innodb中跟数据持久性、一致性有关的日志，有以下几种：

- Bin Log:是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的。
- Redo Log:记录了数据操作在物理层面的修改，顺序记录。mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，**事务进行中时会不断的产生redo log，在事务提交时进行一次flush刷新操作，保存到磁盘中**。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。
- Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，**通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC**。

[参考](https://www.jianshu.com/p/f692d4f8a53e)
[参考](https://blog.csdn.net/lzw2016/article/details/89420391)

#### Undo Log

Undo Log 是为了实现**事务的原子性**，在MySQL数据库 `InnoDB` 存储引擎中，还用Undo Log来实现多版本并发控制(简称：`MVCC`)。

##### **事务的原子性(Atomicity)**

事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生 了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。

原理:Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。

##### **事务的持久性(Durability)**

 **事务一旦完成**，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。用Undo Log实现**原子性**和**持久化的事务的简化过程。** 

假设有A、B两个数据，值分别为1,2。

> A.事务开始.
>
> B.记录A=1到undo log.
>
> C.修改A=3.
>
> D.记录B=2到undo log.
>
> E.修改B=4.
>
> F.将undo log写到磁盘。
>
> G.将数据写到磁盘。H.事务提交

这里有一个隐含的前提条件：‘数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘’。

之所以能同时保证**原子性和持久化**是因为以下特点：

 A. 更新数据前记录Undo log(记录老数据)。

B. 为了保证持久性，必须将**数据在事务提交前写到磁盘**。只要事务成功提交，数据必然已经持久化。

C. **Undo log必须先于数据持久化到磁盘**。如果在G,H之间系统崩溃，undo log是完整的，可以用来回滚事务。

D. 如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。

缺陷：**每个事务提交前将数据和Undo Log（后面Redo Log将其数据和Undo Log都看作数据一回事儿进行简化I/0）写入磁盘，这样会导致大量的磁盘IO，因此性能很低。**如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log.

#### Redo Log

原理和Undo Log相反，Redo Log记录的是新数据的备份。**在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。**当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

##### Undo + Redo事务的简化过程

假设有A、B两个数据，值分别为1,2.

> A.事务开始.
>
> B.记录A=1到undo log.
>
> C.修改A=3.
>
> D.记录A=3到redo log.
>
> E.记录B=2到undo log.
>
> F.修改B=4.
>
> G.记录B=4到redo log.
>
> H.将redo log写入磁盘。
>
> I.事务提交

##### Undo + Redo事务的特点

A. 为了保证持久性，**必须在事务提交前将Redo Log持久化。**

B. 数据不需要在事务提交前写入磁盘，而是缓存在内存中。

C. Redo Log 保证事务的持久性。

D. Undo Log 保证事务的原子性。

E. 有一个隐含的特点，数据必须要晚于redo log写入持久存储。 

##### IO性能

Undo + Redo的设计主要考虑的是提升IO性能。虽说通过缓存数据，减少了写数据的IO. 但是却引入了新的IO，即写Redo Log的IO。如果Redo Log的IO性能不好，就不能起到提高性能的目的。

A. 为了保证Redo Log能够有比较好的IO性能，InnoDB 的 Redo Log的设计有以下几个特点：尽量保持Redo Log存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。以顺序追加的方式记录Redo Log,通过顺序IO来改善性能。

B. 批量写入日志。日志并不是直接写入文件，而是先写入redo log buffer.当需要将日志刷新到磁盘时(如事务提交),将许多日志一起写入磁盘.

C. 并发的事务共享Redo Log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的：

> 记录1: <trx1, insert …>
>
> 记录2: <trx2, update …>
>
> 记录3: <trx1, delete …>
>
> 记录4: <trx3, update …>
>
> 记录5: <trx2, insert …>

D. 因为C的原因,当一个事务将Redo Log写入磁盘时，也会将其他未提交的事务的日志写入磁盘。

E. Redo Log上只进行顺序追加的操作，当一个事务需要回滚时，它的Redo Log记录也不会从Redo Log中删除掉。

#### 恢复(Recovery)

##### 恢复策略

 前面说到未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理.有2中不同的恢复策略： 

* A. 进行恢复时，只重做已经提交了的事务。  
* B. 进行恢复时，重做所有事务包括**未提交的事务**和**回滚了的事务**。然后通过Undo Log回滚那些    未提交的事务。   

##### InnoDB存储引擎的恢复机制

MySQL数据库InnoDB存储引擎使用了B策略, InnoDB存储引擎中的恢复机制有几个特点：

A. 在重做Redo Log时，并不关心事务性。 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。**尽管事务ID等事务相关的内容会记入Redo Log**，这些内容只是被当作   要操作的数据的一部分。**(恢复含有未提交的事务)**

B. 使用B策略就必须要将Undo Log持久化，而且必须要在写Redo Log之前将对应的Undo Log写入磁盘。Undo和Redo Log的这种关联，使得持久化变得复杂起来。为了降低复杂度**，InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中。这样undo log就可以象数据一样缓存起来，而不用在redo log之前写入磁盘了。（恢复回滚了的事务）**

包含Undo Log操作的Redo Log，看起来是这样的：

> 记录1: <trx1, Undo log insert <undo_insert …>>
>
> 记录3: <trx2, Undo log insert <undo_update …>>
>
> 记录4: <trx2, update …>
>
> 记录5: <trx3, Undo log insert <undo_delete …>>
>
> 记录6: <trx3, delete …>

C. 到这里，还有一个问题没有弄清楚。既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？

确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。**回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中。** 一个回滚了的事务的Redo Log，看起来是这样的：

> 记录1: <trx1, Undo log insert <undo_insert …>>
>
> 记录2: <trx1, insert A…>
>
> 记录3: <trx1, Undo log insert <undo_update …>>
>
> 记录4: <trx1, update B…>
>
> 记录5: <trx1, Undo log insert <undo_delete …>>
>
> 记录6: <trx1, delete C…>
>
> 记录7: <trx1, insert C>
>
> 记录8: <trx1, update B to old value>
>
> 记录9: <trx1, delete A>

**一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性.**

[参考](https://www.qiancheng.me/post/coding/mysql-001)

### MVCC(多版本并发控制)

​        MVCC (Multi-Version Concurrency Control)，即多版本并发控制。MVCC在InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。（总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案）

**MVCC的实现：**       

InnoDB 的MVCC 通过**在每行记录后面保存两个隐藏的列来实现**，这两个列一个保存了行的**创建时间**，一个保存行的**过期时间**。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。

- SELECT

  InnoDB会根据以下两个条件检查每行记录：

  1. InnoDB只**查找**版本**早于当前事务版本的数据行**（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
  2. **行的删除版本要么未定义，要么大于当前事务版本号。**这可以确保事务读取到的行，在事务开始之前未被删除。

  只有符合上述两个条件的记录，才能返回作为查询结果

- INSERT

  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

- DELETE

  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

- UPDATE

  InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
   保存这两个额外系统版本号，**使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，**并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作

举例说明

```cpp
create table mvcctest( 
id int primary key auto_increment, 
name varchar(20));
```

**transaction 1:**

```csharp
start transaction;
insert into mvcctest values(NULL,'mi');
insert into mvcctest values(NULL,'kong');
commit;
```

假设系统初始事务ID为1；

| ID   | NAME | 创建时间 | 过期时间  |
| ---- | ---- | -------- | --------- |
| 1    | mi   | 1        | undefined |
| 2    | kong | 1        | undefined |

**transaction 2:**

```csharp
start transaction;
select * from mvcctest;  //(1)
select * from mvcctest;  //(2)
commit
```

SELECT

假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务3：

**transaction 3:**

```csharp
start transaction;
insert into mvcctest values(NULL,'qu');
commit;
```

| ID   | NAME | 创建时间 | 过期时间  |
| ---- | ---- | -------- | --------- |
| 1    | mi   | 1        | undefined |
| 2    | kong | 1        | undefined |
| 3    | qu   | 3        | undefined |

事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过**乐观锁的方式避免了幻读的产生**

**UPDATE**

假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：

**transaction session 4:**

```bash
start transaction;
update mvcctest set name = 'fan' where id = 2;
commit;
```

InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间

| ID   | NAME | 创建时间 | 过期时间  |
| ---- | ---- | -------- | --------- |
| 1    | mi   | 1        | undefined |
| 2    | kong | 1        | 4         |
| 2    | fan  | 4        | undefined |

事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在**两次读取时读取到的数据的状态是一致的（不可重复读问题解决）**

**DELETE**

假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：

**transaction session 5:**

```csharp
start transaction;
delete from mvcctest where id = 2;
commit;
```

| ID   | NAME | 创建时间 | 过期时间  |
| ---- | ---- | -------- | --------- |
| 1    | mi   | 1        | undefined |
| 2    | kong | 1        | 5         |

事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的



[参考](https://www.jianshu.com/p/f692d4f8a53e)

## 存储引擎

​        数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。**MySql的核心就是存储引擎**。默认支持的也是 **InnoDB**。

![img](http://images2015.cnblogs.com/blog/801753/201511/801753-20151104192103274-2024174925.png)

常见的两种存储引擎是InnoDB和MyISAM。

### **1、InnoDB**

　　InnoDB是默认的数据库存储引擎，主要特点有：

　　**a、可以自动增长列**，方法是：auto_increment。

　　**b、支持事务。默认的事务隔离级别是可重复读，通过MVCC（并发版本控制）来实现。**【**重点**】

　　**c、使用的锁粒度为行级锁，可以支持更高的并发。**

　　**d、支持外键约束；**外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。

　　**e、配合一些热备工具可以支持在线热备份。**

　　**f、在 InnoDB 中存着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；**

　　**g、对于 InnoDB 类型的表，其数据的物理组织形式是聚簇表。**所有的数据按照主键来组织，数据和索引放在一块，都位于B+树的叶子节点上。

 

　　当然，InnoDB 的存储表和索引也有下面两种形式：

　　**（1）使用共享表空间存储：**所有的表和索引存放在同一个表空间中。

　　**（2）使用多表空间存储：**表结构放在frm文件，数据和索引放在IBD文件中。分区表的话，每个分区对应单独的IBD文件，分区表的定义可以查看我的其他文章。使用分区表的好处在于提升查询效率。

　　**对于InnoDB来说，最大的特点在于支持事务。但是这是以损失效率来换取的。**

　

### **2、MyISAM**

　　使用这个存储引擎，每个 MyISAM 在磁盘上存储形成3个文件：

　　　　a、frm文件：存储表的定义数据；

　　　　b、MYD文件：存放表具体记录的数据；

　　　　c、MYI文件：存储索引；

　　frm 和 MYI 可以存放在不同的目录下。MYI 文件用来存储索引，但仅保存记录所在页的指针，索引的结构是**B+树**结构。

　　下面这张图就是MYI文件保存的机制：

![img](https://img2020.cnblogs.com/blog/1254814/202003/1254814-20200329145326651-2112224516.png)

 　从这张图可以发现，这个存储引擎通过MYI的B+树结构来查找记录页，再根据记录页查找记录。并且支持全文索引、B树索引和数据压缩。

　　支持数据的类型也有三种：

　　**（1）静态固定长度表**

　　这种方式的优点在于存储速度非常快，容易发生缓存，而且表发生损坏后也容易修复。缺点是占空间。这也是默认的存储格式。

　　**（2）动态可变长表**

　　优点是节省空间，但是一旦出错恢复起来比较麻烦。

　　**（3）压缩表**

　　上面说到支持数据压缩，说明肯定也支持这个格式。在数据文件发生错误时候，可以使用check table工具来检查，而且还可以使用repair table工具来恢复。

　　有一个重要的特点那就是**不支持事务**，但是这也意味着他的存储速度更快。如果你的读写操作允许有错误数据的话，只是追求速度，可以选择这个存储引擎。



[参考](https://www.cnblogs.com/qiuhaitang/p/12574516.html)



#### **二者的区别**

**（更加详细的说明还待扩展）**

1. 事务安全（MyISAM不支持事务，INNODB支持事务）

2. 外键 （MyISAM 不支持外键， INNODB支持外键. 

3. 锁机制（MyISAM是表锁，innodb是行锁）

4. 查询和添加速度（MyISAM批量插入速度快）

5. 支持全文索引（MyISAM支持全文索引，INNODB不支持全文索引）

6. MyISAM内存空间使用率比InnoDB低

## 索引

### 一、定义

​       **索引**也叫**键**，是存储引擎用于快速找到记录的一种**数据结构**。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。

​       索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免排序和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。

​        在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能使用索引的最左前缀。

​       **缺点：**过多的使用索引将会造成滥用。虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。而且建立索引会占用磁盘空间的索引文件。



### 二、索引的数据结构

索引存储在文件系统中，**索引**的文件存储形式与**存储引擎**相关。

常见的MySQL主要的索引文件结构：Hash索引，B-Tree索引，B+Tree索引，其中InnoDB引擎，默认的是B+树。



#### **常见面试问题**

**1、数据库为什么是 B+ 树而不是hash表？**

1. hash表只能匹配是否相等，**不能实现范围查找**

   由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。例如：select * from xx where id > 23; 这时就没办法索引了。

2. 当需要按照索引进行order by排序操作时，hash值**没办法支持排序**。

   特别是在有大量重复键值的情况下，哈希索引的效率是非常低的

3. Hash 索引**不能利用部分索引键查询**。

   组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了a和b也可以查询的，而Hash 索引在计算 Hash 值的时候，是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，没办法支持部分索引。

4. 当数据量很大时，**hash冲突的概率也会非常大**。

   特别是在有大量重复键值的情况下，哈希索引的效率是非常低的

[参考1](https://www.jianshu.com/p/2bb912caa3b1)

[参考2](https://blog.csdn.net/Alen_xiaoxin/article/details/104753391)



**2.B+树和B树** 

* （一） **初始设计索引的数据结构（指导思想）**

  * 区域查询

    当查找到起点节点 10 后，再顺着链表进行遍历，直到链表中的节点数据大于区间的终止值为止。**所有遍历到的数据，就是符合区间值的所有数据**。

    ![](./img/查找.png)

  * 优化树的高度

    为了节省内存，我们只能把树存储在硬盘中。那么，**每个节点的读取或者访问，都对应一次硬盘 IO 操作。每次查询数据时磁盘 IO 操作的次数，也叫做IO 渐进复杂度，也就是树的高度**。所以，我们要减少磁盘 IO 操作的次数，也就是 **要降低树的高度**。

    

    这里将二叉树变为了 M 叉树，降低了树的高度，那么这个 M 应该选择多少才合适呢？

    ![](./img/树的高度.png)

    **关键：对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才合适呢？**

    不管是内存中的数据还是磁盘中的数据，操作系统都是按页（一页的大小通常是 4kb，这个值可以通过`getconfig(PAGE_SIZE)`命令查看）来读取的，一次只会读取一页的数据。

    如果要读取的数据量超过了一页的大小，就会触发多次 IO 操作。所以在选择 m 大小的时候，**要尽量让每个节点的大小等于一个页的大小。**

    **结论：一般实际应用中，出度 d（树的分叉数）是非常大的数字，通常超过 100；树的高度（h）非常小，通常不超过 3。**

* （二）B树（也就是 B-树）

  * 关键字分布在整棵树的所有节点。

  * 任何一个关键字 **出现且只出现在一个节点中。**

  * 搜索有可能在 **非叶子节点** 结束。

  * 其搜索性能等价于在关键字全集内做一次二分查找。

    ![](./img/B.png)

* （三）B+树

  * 非叶子节点的子树指针与关键字个数相同。

  * 非叶子节点的子树指针 P[i]，指向关键字属于 **[k[i],K[i+1])** 的子树（**注意：区间是前闭后开**)。

  * **为所有叶子节点增加一个链指针**。

  * **所有关键字都在叶子节点出现**。

    ![](./img/Bplus.png)

  * 特性

    * 所有的关键字 **都出现在叶子节点的链表中**，且链表中的关键字是有序的。
    * **搜索只在叶子节点命中**。
    * 非叶子节点相当于是 **叶子节点的索引层**，叶子节点是 **存储关键字数据的数据层**。

* （四）相对 B 树，B+树做索引的优势

  - B+树的磁盘读写代价更低。**B+树的内部没有指向关键字具体信息的指针，所以其内部节点相对 B 树更小**，如果把所有关键字存放在同一块盘中，那么盘中所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，**相应的，IO 读写次数就降低了**。
  - **树的查询效率更加稳定**。B+树所有数据都存在于叶子节点，所有关键字查询的路径长度相同，每次数据的查询效率相当。而 B 树可能在非叶子节点就停止查找了，所以查询效率不够稳定。
  - **B+树只需要去遍历叶子节点就可以实现整棵树的遍历**。
  
  [参考](https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c)



**3.底层B+树， 为什么不用B树?**

我认为最关键的是应用场景，因为mysql场景里，有很多例如: score > 90 and score< 120 范围查询。
而B+树这种数据结构能更好满足这种**范围查询**输出。理论上，**单个节点**的查找，B树性能可能要高于B+

**B和B+树核心区别**

B+树的非叶子节点只保存key值，而B-树存储key值和data值，这样B+树每次读取时可以读取到更多的key值；

- mysql进行**区间访问**时，由于B+树叶子节点之间用指针相连，只需要遍历所有的叶子节点即可；而B-树则需要中序遍历那样遍历
- B+树非叶子节点只存储key值，而B-树存储key值和data值，导致B+树的层级更少，查询效率更高
- B+树所有关键词地址都存在叶子节点上，所以每次查询次数都相同，比B-树稳定

[参考](https://zhuanlan.zhihu.com/p/158205230)





**3.B+树的时间复杂度，为什么是log（N），B+树上查询数据的流程。** 

B+树的时间复杂度: 一棵含n个结点的**B树的高度**也为O（logn)   （二叉树 2^m = n ）

查询流程

<img src="https://pic4.zhimg.com/v2-25c1c0b8a4ea8c300e180e3d87339bfb_r.jpg" alt="preview" style="zoom:50%;" />





### 三、索引分类

* 从存储结构上来划分

  * Btree 索引（B+tree，B-tree)
  * 哈希索引
  * full-index 全文索引
  * RTree -- 空间索引

* 从应用层次上来划分

  * 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。
  * 唯一索引：索引列的值必须唯一，但允许有空值。
  * 复合索引：一个索引包含多个列。

* 从表记录的排列顺序和索引的排列顺序是否一致来划分

  * 聚集索引：表记录的排列顺序和索引的排列顺序一致。

    聚集索引就是以**主键创建的索引**。

    聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。

    **缺点**：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序

  * 非聚集索引：表记录的排列顺序和索引的排列顺序不一致。

    非聚集索引就是以**非主键创建的索引（也叫做二级索引）**。

    **索引的逻辑顺序与磁盘上行的物理存储顺序不同**，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是我们所说的**回表**。

  * 区别

    - 聚集索引在叶子节点存储的是表中的数据。
    - 非聚集索引在叶子节点存储的是主键和索引列。

    [参考](https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c)  





1.**普通索引** index : 是最基本的索引，它没有任何限制，目的是加速查找。

2.**唯一索引**：与前面的普通索引类似，不同的就是：索引列的值必须**唯一**，但允许有空值。
    **主键索引**：primary key ：加速查找+约束（不为空且唯一）
    唯一索引：unique：加速查找+约束 （唯一）

3.**联合索引**（组合索引）：可以使用多个列组合进行索引。
    -primary key(id,name):联合主键索引
    -unique(id,name):联合唯一索引
    -index(id,name):联合普通索引

4.**全文索引** (fulltext) :用于搜索很长一篇文章的时候，效果最好。

​       通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。

​       MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的"文档指针"。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。

5.**空间索引** (spatial) :了解就好，几乎不用

​        MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。

#### 补充：联合索引的最左匹配

​       在创建多列索引时，根据需求，把使用最频繁的一列放在where子句中的最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

​      所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。



### 四、聚簇索引

​      聚簇索引不是一种索引类型，而**是一种数据存储方式**。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚簇索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。（非聚簇索引就是数据文件和索引文件分开）

优点：

① 可以把相关数据保存在一起。

② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。

③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

缺点：

① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。

② 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。

③ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。

④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。



### 五、覆盖索引

​        覆盖索引指一个索引包含或覆盖了**所有**需要查询的字段的值，不再需要根据索引**回表**查询数据（先定位主键值，再定位行记录）。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。（B-Tree 索引的数据和索引放在一起）

​      也就是说，当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。

 例子：

```sql
create table user(
  id int primary key,
  name varchar(20),
  sex varchar(5),
  index(name)
)engine=innodb;
```

第一个SQL语句：　　

 ![img](https://img2018.cnblogs.com/blog/885859/201907/885859-20190729185028557-1703422478.png)

```sql
select id,name from user where name='shenjian';　
```

能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

 

第二个SQL语句：         

![img](https://img2018.cnblogs.com/blog/885859/201907/885859-20190729185053070-767208274.png)

```sql
select id,name,sex from user where name='shenjian';　
```

能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。



**优点：**

① 索引条目通常远小于数据行大小，可以极大减少数据访问量。

② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。(不懂)

③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。



### 六、索引使用原则

- **建立索引**

  ​        对查询频次较高且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，应当挑选最常用、过滤效果最好的列的组合。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

- **使用前缀索引**

  ​       索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。

- **选择合适的索引顺序**

  ​        当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。

- **删除无用索引**

  ​       MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A,B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。



### 七、索引失效

​     索引失效的几种情况： 

- 如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。
- 如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。
- MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做比较。这种情况下 MySQL 只能提取数据行的值而不是索引值来做比较。
- 如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。
- 对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。
- 如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。
- 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。







## mysql 内连接外连接

* 内连接

  关键字：inner join on

  语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;

  ![](./img/内连接.png)

  ![](./img/交集.png)

* 外连接

  * 左连接（左外连接）
  
    关键字：left join on / left outer join on
  
    语句：select * from a_table a left join b_table b on a.a_id = b.b_id;
  
    ![image-20210128203417209](./img/左外连接)
  
  * 右外连接
  
    关键字：right join on / right outer join on
  
    语句：select * from a_table a right outer join b_table b on a.a_id = b.b_id;
  
    说明：
  
    right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。
  
    与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而**右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。**

## having 和 where 的区别

“Where” 是一个约束声明，使用Where来约束来自数据库的数据，Where是在**结果返回之前**起作用的，且**Where中不能使用聚合函数**（聚合函数可以用来统计、求和、求最值等）。
 “Having”是一个过滤声明，是在查询**返回结果集以后**对查询结果进行的过滤操作，在Having中**可以使用**聚合函数。

having可以让我们筛选成组后的各组数据，where在聚合前先筛选记录。也就是说where是作用在group by和having之前，而having是在聚合后对组记录进行筛选。

```csharp
select region,sum(population),sum(area) from bbc group by region having sum(population) > 1000000
```

注意：在这里，我们不能用where来筛选超过1000000的地区，因为表中不存在这样一条记录。相反，having子句可以让我们筛选成组后的各组数据。

[参考](https://www.jianshu.com/p/fbf5d6376f9d)

## mysql 写查询：给定name， subject ，score， 查挂了两门课程以上学生的个数

  ![sql1](./img/sql1.png)

  ```sql
  select name,sum(score<60) as gks from student group by name;
  ```

  ![sql2](./img/sql2.png)

  ```sql
  select name,sum(score<60) as gks from student group by name having gks>2;
  ```

  ![sql1](img/sql3.png)

  ```sql
   select count(name) from(select name,sum(score<60) as gks from student group by name having gks>2)as a;
  ```

  ![sql1](img/sql4.png)

  [参考](https://blog.csdn.net/qq_41051690/article/details/98749438)

