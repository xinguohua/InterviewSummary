https://www.nowcoder.com/discuss/607156?source_id=discuss_experience_nctrack&channel=-1
https://www.nowcoder.com/discuss/607106?source_id=discuss_experience_nctrack&channel=-1
https://www.nowcoder.com/discuss/606744?source_id=discuss_experience_nctrack&channel=-1
https://www.nowcoder.com/discuss/603222?source_id=discuss_experience_nctrack&channel=-1
https://www.nowcoder.com/discuss/573163?source_id=discuss_experience_nctrack&channel=-1



## MYSQL
mysql
mysql的优化
存储引擎
数据库范式
索引优化
A：基本功就不说了，补充了下 Innodb 用next key lock 解决可重复读下的幻读问题，事务隔离 A 使用 undo log，D 使用 redo log 实现等等。。
数据库的事物怎么实现的inoodb redolog



### 一、数据库三大范式

**范式**：在设计数据库时，为了使其冗余较小、结构合理，设计数据库时必须遵循一定的规则。在关系型数据库中，这种规则被称为范数。范数是符合某一设计规则的总结。

**三大范式：**

- **第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。**强调的是列的原子性，即列不能够再分成其他几列。

  例子：

  非第一范式举例：

  ![img](https://img-blog.csdn.net/20180601172742716?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg4NjU1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  原因：高三年1班含有年级和班级信息，可继续拆分，为非原子信息。

  **改：**

  ![img](https://img-blog.csdn.net/20180601172902836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg4NjU1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  

- **第二范式（2NF）**：**在1NF的基础上，数据库表中的每一列都与主键完全相关，而不能只与主键的部分相关。**否则数据列中出现数据重复，会造成数据冗余。

  例子：

  假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，主键为联合主键(学号, 课程名称)，因为存在如下关系：

  ```
  (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)
  
  如果一个人选了好几门课，会造成数据重复，形成冗余。
  学号 课程名称 姓名 年龄 成绩 学分
  01   数学   张三  18  99   4
  01   语文   张三  18  83   4
  ```

  这个数据库表不满足第二范式，因为存在如下决定关系：

  ```
  (课程名称) → (学分) 
  
  (学号) → (姓名, 年龄)
  ```

  即非主属性依赖于主键的一部分（如学分只依赖于课程名称，而不是学号和课程名称）。

  **改：**

  把选课关系表SelectCourse改为如下三个表，就符合了第二范式。 

  ```
  学生：Student(学号, 姓名, 年龄)；
  
  课程：Course(课程名称, 学分)； 
  
  选课关系：SelectCourse(学号, 课程名称, 成绩)。
  ```

  

- **第三范式（3NF）**：**在2NF的基础上，数据库表中的每一列和主键直接相关，而不是间接相关。**也就是属性不能传递依赖于主属性，像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。会形成数据冗余。

  例子：

  假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字"学号"，因为存在如下决定关系

  ```
  (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)
  ```

  这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系

  ```
  (学号) → (所在学院) → (学院地点, 学院电话)
  ```

  改：

  把学生关系表分为如下两个表

  ```
  学生：(学号, 姓名, 年龄, 所在学院)；
  
  学院：(学院, 地点, 电话)。
  ```

  

[参考](https://blog.csdn.net/weixin_41886551/article/details/80540636)





### **二、MySQL事务日志架构图**

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84NjE1NWE5NS0zYzgzLTQyMzgtOWIyYi1lMGIwMzE0MDkxMjQucG5n?x-oss-process=image/format,png)

#### 补充：**MySQL 的逻辑架构**

**第一层是连接层**，主要提供连接处理、授权认证、安全等功能。

**第二层服务层，实现了 MySQL 核心服务功能**，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。

**第三层是存储引擎层**，**存储引擎负责 MySQL 中数据的存储和提取**。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mMzIxZTAzMy05ZTljLTQ1N2YtYTZhYi1mY2ExYzk3ZDJkOTIucG5n?x-oss-process=image/format,png" alt="MySQL的逻辑架构" style="zoom:80%;" />



[参考](https://blog.csdn.net/u014398524/article/details/106505549/)



### **二、InnoDB 和 MyISAM 的区别**

**简洁版本**：

1. 事务（InnoDB支持事务，MyISAM不支持事务）
2. 外键 （InnoDB支持外键，MyISAM 不支持外键）
3. 支持全文索引（MyISAM支持全文索引，InnoDB不支持全文索引）（**MySQL 5.6** 及以后的版本， InnoDB 存储引擎也支持全文索引）
4. 锁机制（InnoDB是行锁，MyISAM是表锁）
5. 内存空间（MyISAM只缓存索引，InnoDB缓存索引和数据）
6. 查询和添加速度



详细版本：

InnoDB是一个事务型的存储引擎，支持回滚，设计目标是处理大数量数据时提供高性能的服务，**是 MySQL 5.5之后作为默认的存储引擎**。MyISAM 是 MySQL 5.5 之前的默认引擎，它的设计目标是快速读取。

- **InnoDB 支持事务，MyISAM 不支持**事务。事务可以进行故障恢复，支持高并发。但是使用事务后系统的开销大。

- **InnoDB 支持外键，而 MyISAM 不支持**外键。（如果关键字在一个表中是主键，那么这个关键字被称为另一个表的外键）外键可以维护数据的一致性，完整性，会更可靠，但是可能会降低性能，且维护麻烦。

  - 比如一个业务流水表，频繁插入数据，如果这个表身上有3外键，那么每次插入一条，就必须对这3个外键对应的3个表做相应的查找判断有无对应数据，如果这3个表也很大，那就这3个表的判断时间就很长。

- **InnoDB支持行锁，MyISAM支持表锁**。详细见下文的锁机制。

- **InnoDB 不支持全文索引，而 MyISAM 支持全文索引**。MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引，**MySQL 5.6** 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。

  - 全文索引：被用来存储在全文搜索下**某个单词**在一个文档或者一组文档中的存储位置的映射，也就是想通过**关键字**匹配进行查询。它是文档检索系统中最常用的数据结构。
  - **全文索引的原理**是先定义一个词库，然后在文章中**查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳**，这样就相当于对文件建立了一个以词库为目录的索引，这样查找某个词的时候就能很快的定位到该词出现的位置。例如MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的"文档指针"。

- **查询和添加速度**。关于查询速度和添加速度，不能一概而论，要考虑并发情况和不同的使用场景。MyISAM 适合读多，并发少的场景，当并发操作多的时候，查询速度会降低。

  - 当查询非主键的字段时 , MyISAM查询性能更好，从索引文件数据文件的设计来看 , myisam每一个索引字段都有上面的索引树：MyISAM直接找到物理地址后就可以直接定位到数据记录，但是InnoDB查询到叶子节点后，还需要再查询一次主键索引树，才可以定位到具体数据。等于MyISAM一步就查到了数据，但是InnoDB要两步，那当然MyISAM查询性能更高。

  - 如果是查询的主键的字段时,Innodb更好一些 , 因为直接从主键的聚簇索引里就取到了数据 , 不需要再次用指针去拿。

  - 还有其他的场景，不一一举例。

    ![img](https://img2020.cnblogs.com/blog/726254/202012/726254-20201209133556948-1124724597.png)

    

    ![img](https://img2020.cnblogs.com/blog/726254/202012/726254-20201209133826183-36764981.png)

    

所以如果一个表**插入不频繁，查询非常频繁**，可以选择 MyISAM 存储。若一个表**更新和查询都相当的频繁，并且表锁定的机会比较大的情况**，可以选择 InnoDB。



#### 补充：**MyISAM 和 InnoDB 的数据结构**

MyISAM 和 InnoDB 两种引擎所使用的**索引的数据结构**都是 **B+ 树**，**不过区别在于**：

- MyISAM 中 B+ 树的数据结构存储的内容是**实际数据的地址值**，它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为**非聚集索引（Non-clustered，非聚簇索引）。**

- InnoDB 中 B+ 树的数据结构中存储的都是**实际的数据**，这种索引有被称为**聚集索引（Clustered，聚簇索引）**。

  

​      MyISAM索引结构如下图所示，由于 **MyISAM 的索引文件仅仅保存数据记录的地址**。MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，**如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。**

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icHoerKO3NjLQ1BURibV1PAyjaXgia525ZkNOibmTjICtsCgp9Rx8iauEjE8oFjhDsJudian6dN4YvD82eCdL5Fibmtbg/640?wx_fmt=png)



对于 InnoDB 来说，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的**叶节点 data 保存了完整的数据记录**。

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icHoerKO3NjLQ1BURibV1PAyjaXgia525Zk7YZljMrXUxG1UiasxH99iauYgu7dPmGTGoUG9iaysL8sNMIAILcHefCHA/640?wx_fmt=png)



[参考](https://blog.csdn.net/hyg0811/article/details/100520550)





### **三、数据库的锁机制**

​        **锁是计算机协调多个进程或纯线程并发访问某一资源的机制。**在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是**不同的存储引擎支持不同的锁机制**。MySQL大致可归纳为以下3种锁：

- **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

- **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

- **页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。（不重要）（在 MySQL5.1及其以后版本中，将不再提供BDB支持）

  ![img](https://img2018.cnblogs.com/blog/1044429/201811/1044429-20181102154150537-672525342.png)



**MySQL的读写锁**：在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为**共享锁和排它锁(独占锁)，也叫读锁和写锁**。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。

在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。**写锁比读锁有更高的优先级**，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。



#### 1.表锁和行锁

**表锁**是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表。**MyISAM**实现了以下两种类型的行锁。

- **共享锁(读锁)**，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；

- **排他锁(写锁)**，会阻塞其他用户对同一表的读和写操作；

- MyISAM表的**读操作和写操作之间**，以及**写操作之间**是**串行**的。当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

- 当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为**MySQL认为写请求一般比读请求重要**。**这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。**这种情况有时可能会变得非常糟糕。但是我们通过一些设置来调节MyISAM的调度行为，例如更改参数调整读锁优先级等。

  

(InnoDB 存储引擎既支持行级锁，也支持表级锁，默认情况下是采用行级锁。)

**行锁**可以最大程度地支持并发，同时也带来了最大开销。表锁会锁定表中的一行数据。**InnoDB**实现了以下两种类型的行锁。()

- **共享锁（读锁）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- **排他锁（写锁）**：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
- 行锁只在存储引擎层实现，而服务器层没有实现。
- InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：**只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁**。在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。



**Next-Key LOCK**

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Gap Lock）。

**Next-Key LOCK是行锁和间隙锁的组合**，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。（也有文章中直接把间隙锁等同next key lock的）

  举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：

```
SELECT * FROM emp WHERE id > 100 FOR UPDATE
```

  是一个范围条件的检索，InnoDB不仅会对符合条件的id值为101的记录加锁，也会对id大于101（这些记录并不存在）的“间隙”加锁。

 **InnoDB使用Next-Key LOCK的目的，是为了防止幻读，以满足相关隔离级别的要求**，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。（间隙锁是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制)





#### **2.死锁**

**死锁：是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致无限等待的状态。**

- **ＭyISAM表锁是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁**。
- **在InnoDB中，锁是逐步获得的，这就决定了InnoDB可能发生死锁。**
  - 当多个事务试图以不同顺序锁定资源时就可能会产生死锁，例如事务1先请求锁1，再请求锁2。而事务2先请求锁2，再请求锁1，可能会造成死锁。



**解决死锁**

​      发生死锁后，InnoDB一般都能自动检测到，并**使一个事务释放锁并回滚，另一个事务获得锁，继续完成事务**。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置**锁等待超时参数**innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。**（回滚+等待超时机制）**



[参考](https://www.cnblogs.com/chenqionghe/p/4845693.html)





### 四、事务日志

MySQL日志系统是数据库的重要组件，用于记录数据库的更新和修改。若数据库发生故障，可通过不同日志记录恢复数据库的原来数据。因此实际上日志系统直接决定着MySQL运行的鲁棒性和稳健性。

MySQL的日志有很多种，如二进制日志（binlog）、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种日志：redo log（重做日志）和undo log（回滚日志）。这里将重点针对InnoDB引擎，对重做日志、回滚日志和二进制日志这三种进行分析。

#### **1.redo log**

重做日志（redo log）是InnoDB引擎层的日志，用来**记录事务操作引起数据的变化**，**记录的是数据页的物理修改**。

**为什么需要redo log？**

我们都知道，事务的四大特性里面有一个是 **持久性** ，即**只要事务提交成功，那么对数据库的修改就被永久保存下来了，不可能再回到原来的状态**。

那么 `mysql`是如何保证持久性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：

1. 因为 `Innodb` 是以 `页` 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源！
2. 一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！

因此 `mysql` 设计了 `redo log` ，**InnoDB引擎对数据的更新是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略，再将日志中的内容更新到磁盘之中。这就是所谓的预写式技术（Write Ahead logging）**。这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。如果整个事务执行的过程系统崩溃或者断电了，在系统重启的时候，**恢复机制会将redo log中已提交的事务重做，保证事务的持久性。**



**脏数据刷盘**

前面说过，redo log实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 `redo log`实现上采用了**大小固定，循环写入**的方式，当写到结尾时，会回到开头循环写日志。**在redo log日志中设置了两个标志位置，`write_pos`和`checkpoint`，分别表示记录写入的位置和记录擦除的位置**。如下图：

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hMmRjNGQxNi1iNmFjLTQ5NWYtODI2Ni0zNTE3NGNhZGNiZTAucG5n?x-oss-process=image/format,png" alt="img" style="zoom:67%;" />

当`write_pos`标志到了日志结尾时，会从结尾跳至日志头部进行重新循环写入。所以redo log的逻辑结构并不是线性的，而是可看作一个圆周运动。`write_pos`与`checkpoint`中间的空间可用于写入新数据，写入和擦除都是往后推移，循环往复的。

<img src="https://img-blog.csdnimg.cn/20200602215621316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzOTg1MjQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

​       当`write_pos`追上`checkpoint`时，表示redo log日志已经写满。这时不能继续执行新的数据库更新语句，需要停下来先删除一些记录，执行`checkpoint`规则腾出可写空间。

checkpoint规则：checkpoint触发后，将buffer中脏数据页和脏日志页都刷到磁盘。（脏数据：指内存中未刷到磁盘的数据。）



**脏日志刷盘**

​      除了上面提到的对于脏数据的刷盘，实际上redo log日志在记录时，**为了保证日志文件的持久化，也需要经历将日志记录从内存写入到磁盘的过程**。redo log 包括两部分：**一个是内存中的日志缓冲( `redo log buffer` )，另一个是磁盘上的日志文件( `redo log file`)。**

​      mysql每执行一条数据库操作的语句，先将记录写入 `redo log buffer`，后续某个时间点再一次性将多个操作记录写到 `redo log file`。这种 **先写日志，再写磁盘** 的技术就是 WAL(Write-Ahead Logging)预写式技术。

​       在计算机操作系统中，用户空间( `user space` )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( `kernel space` )缓冲区( `OS Buffer` )。因此， `redo log buffer` 写入 `redo logfile` 实际上是先写入 `OS Buffer` ，然后再通过系统调用 `fsync()` 将其刷到 `redo log file`中，过程如下：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9CYXE1bFlwSXc3WE9ZN0V1d24xS0hjOFBXeGhrUjdaZTk3MXpJTlhWd3FwMHNrZW9Za21PUXBHQXRjSmpjcmZYYTFkaDl2eEJERUlvbVl3OVkxdGlidGcvNjQw?x-oss-process=image/format,png)



​       启动 `innodb` 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。重启`innodb` 时，首先会检查磁盘中数据页的 `LSN（逻辑序列号）` ，如果数据页的`LSN` 小于日志中的 `LSN` ，则会从 `checkpoint` 开始恢复。

​       还有一种情况，在宕机前正处于`checkpoint` 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 `LSN` 大于日志中的 `LSN`，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。

#### 2.bin log

二进制日志（binlog）
二进制日志binlog是服务层的日志，还被称为归档日志。binlog主要记录数据库的变化情况，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进二进制日志中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步。

这里binlog所存储的内容看起来似乎与redo log很相似，但是其实不然。redo log是一种物理日志，记录的是实际上对某个数据进行了怎么样的修改；而binlog是逻辑日志，记录的是SQL语句的原始逻辑，比如”给ID=2这一行的a字段加1 "。binlog日志中的内容是二进制的，根据日记格式参数的不同，可能基于SQL语句、基于数据本身或者二者的混合。一般常用记录的都是SQL语句。

这里的物理和逻辑的概念，我的个人理解是：

物理的日志可看作是实际数据库中数据页上的变化信息，只看重结果，而不在乎是通过“何种途径”导致了这种结果；

逻辑的日志可看作是通过了某一种方法或者操作手段导致数据发生了变化，存储的是逻辑性的操作。

同时，redo log是基于crash recovery，保证MySQL宕机后的数据恢复；而binlog是基于point-in-time recovery，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份。

事实上最开始MySQL是没有redo log日志的。因为起先MySQL是没有InnoDB引擎的，自带的引擎是MyISAM。binlog是服务层的日志，因此所有引擎都能够使用。但是光靠binlog日志只能提供归档的作用，无法提供crash-safe能力，所以InnoDB引擎就采用了学自于Oracle的技术，也就是redo log，这才拥有了crash-safe能力。这里对redo log日志和binlog日志的特点分别进行了对比：



在MySQL执行更新语句时，都会涉及到redo log日志和binlog日志的读写。一条更新语句的执行过程如下：



从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。

不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前prepare状态的写入，二是binlog写入之后commit状态的写入。

之所以要安排这么一个两阶段提交，自然是有它的道理的。现在我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入redo log，后写入binlog；要么先写入binlog，后写入redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。

先写入redo log，后写入binlog：

在写完redo log之后，数据此时具有crash-safe能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在redo log写完时候，binlog写入之前，系统发生了宕机。此时binlog没有对上面的更新语句进行保存，导致当使用binlog进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得id=2这一行的数据没有被更新。



先写入binlog，后写入redo log：

写完binlog之后，所有的语句都被保存，所以通过binlog复制或恢复出来的数据库中id=2这一行的数据会被更新为a=1。但是如果在redo log写入之前，系统崩溃，那么redo log中记录的这个事务会无效，导致实际数据库中id=2这一行的数据并没有更新。



由此可见，两阶段的提交就是为了避免上述的问题，使得binlog和redo log中保存的信息是一致的。




[参考](https://blog.csdn.net/u014398524/article/details/106505549/)



#### 3.undo log

​       回滚日志（undo log）同样也是InnoDB引擎提供的日志，**作用就是对数据进行回滚**。当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。

​      数据库事务四大特性中有一个是 **原子性** ，具体来说就是 **原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况**。实际上， **原子性** 底层就是通过 `undo log` 实现的。

​       **undo log和redo log不一样，它属于逻辑日志**。它对SQL语句执行相关的信息进行记录。**当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之前相反的工作。**比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）；对于每个数据删除操作（delete），回滚时会执行数据插入操作（insert）；对于每个数据更新操作（update），回滚时会执行一个相反的数据更新操作（update），把数据改回去。

**undo log由两个作用，一是提供回滚，二是实现MVCC。**



### 五、MVCC 多版本并发控制

​      MVCC (Multi-Version Concurrency Control)，即多版本并发控制。MVCC在InnoDB中的实现主要是为了**提高数据库并发性能，用更好的方式去处理读-写冲突，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。**

#### **1.实现原理**

（**广泛流传的说法**）InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，**这两个列一个保存了行的创建时间，一个保存行的过期时间**。**不过存储的不是实际的时间值而是系统版本号**，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

（**更专业的说法**）InnoDB中的**MVCC实现原理：数据表增加两个隐藏列DATA_TRX_ID和DATA_ROLL_PTR，一个记录当前数据的事务版本号，一个记录指向undo的指针，可以叫回滚指针**(ptr一般用来表示指针)。

举例：

![img](https://img2020.cnblogs.com/blog/468217/202008/468217-20200819155139630-1907672349.png)

有一个事务A，它的执行语句是：

```sql
updata tab set x=20 where id=1
```

事务 A 对值 x 进行更新之后，该行即产生一个新版本和旧版本。假设之前插入该行的事务 ID 为 100，事务 A 的 ID 为 200。操作过程如下

　  1）对 ID = 1 的记录加排他锁

　  2）把该行原本的值拷贝到 undo log 中

​      3）修改改行值并且更新 DATA_TRX_ID，将 DATA_ROLL_PTR 指向刚刚拷贝到 undo log 链中的旧版本记录。（上文中的undo log是一个链表结构，也就是如果多个事务都修改了这行数据，会根据事务ID的先后，以链表形式存放。）



#### 2.Read View

Read View就是事务进行**快照读**操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID。(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

*Read View主要包含如下属性*

1. mIds 代表生成ReadView时，**当前活跃所有的事务ID**，**活跃的意思就是事务开启了还没提交**，这里可以提一点，事务开启事务ID会自增，实际上事务ID就是一个全局自增的数字
2. min_trx_id 表示当前**活跃的mIds中最小的事务ID**
3. max_trx_id 表示**生成ReadView时，最大的事务ID，这里一定不要理解成mIds中最大的ID**，这是一个相当错误的理解，后面再解释
4. creator_trx_id 该**ReadView在哪个事务里创建的**

ReadView有了上面 4个属性后，那么应该以什么样的规则，判断当前事务到底可以读取哪个版本的数据呢？

​       1）如果被访问版本的 data_trx_id **小于** mids 中的最小值，说明生成该版本的事务在 **ReadView** **生成前**就已经提交了，那么该版本**可以**被当前事务访问。

　　2）如果被访问版本的 data_trx_id**大于**当前事务的最大值，说明生成该版本数据的事务在**生成 ReadView 后**才生成，那么该版本**不可以**被当前事务访问。为什么这里的最大值不是mIds的最大值，因为事务ID虽然是全局递增的，但是并不代表事务ID大的一定要在事务ID小的后面提交，也就是**事务开启有先后，但是事务结束的先后和开启的先后并不是完全一致的**，毕竟事务有长有短。如果此时数据的事务版本是200，而mIds中没有200，那么mIds最大值就可能小于200，那么以规则2判断就可能让本该可以访问到的数据因为这个规则，而访问不到了，归根结底就是因为没有正确找到生成ReadView时的最大事务ID，所以不能肯定的说生成该版本数据的事务在生成 ReadView 后才生成。

　　3）如果被访问版本的 data_trx_id属性值在 最大值和最小值之间（包含），那就需要判断一下 trx_id 的值是不是在 mids 列表中。如果在，说明创建 ReadView 时生成该版本所属事务还是活跃的，因此该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

　　通俗点来说，也就是ReadView中通过**最大事务ID，mIds最小事务ID，mIds活跃事务列表**，将当前要读的数据的事务ID分成了3种情况，要么小于mIds的最小事务ID，很明显又在当前活跃的最小事务之前生成，又不在活跃事务中，一定是已提交的事务，这个版本肯定可以访问；要么大于生成ReadView的当前的最大事务ID，很明显在所有活跃事务之后，并且也不可能存在于活跃事务列表中，那么就说明，该版本在当前活跃事务之后才出现，总不能读取到未来的版本吧；要么处于最大最小值之间，这时候就有两种情况，因为并不是说最大最小值之间就一定是活跃的，毕竟先开启的事务并不一定会先结束，事务有大小长短，这时候就很简单，在mIds中就是还没提交的活跃版本，不可被读取，不在就是已经提交的版本，可以被读取。当一个事务要读取一行数据，首先用上面规则判断数据的最新版本也就是那行记录，如果发现可以访问就直接读取了，如果发现不能访问，就通过DATA_ROLL_PTR指针找到undo log，递归往下去找每个版本，直到读取到自己可以读取的版本为止，如果读取不到那就返回空呗。

[参考](https://www.cnblogs.com/rongdi/p/13378892.html)

[参考](https://www.jianshu.com/p/8845ddca3b23)

[参考](https://www.cnblogs.com/axing-articles/p/11415763.html)

#### 补充：mysql如何避免幻读?

使用**MVCC+next-key LOCK**

- 在**快照读**读情况下，mysql通过**mvcc**来避免幻读。
- 在**当前读**读情况下，mysql通过**next-key LOCK**来避免幻读



幻读怎么产生的，假如事务A中先后读取了age>10的数据（age加了索引），第一次读取了一条age=12的，由于紧随其后事务B又插入了一条13，导致事务A接着第二次查询发现获取了两条数据，说好的一条，怎么现在是两条，是不是我喝醉酒眼花了产生了幻觉。

而在mysql的锁定读场景很明显通过间隙锁/next-key锁解决了幻读，当我读取age>10的时候，就把我周围右边的间隙的范围都给锁住，其它事务休想再插入age>10的数据，然后就解决了幻读，从源头上就让你不能插入。

再来说mvcc，在RR隔离级别,当事务A开启的时候会生成一个事务的快照ReadView，里面记录了当前生成的最大事务ID，假定事务A第一次查询就一条记录，这时候事务B的事务ID最多存在两种可能，要么此时正在运行还没提交（废话你要提交了，我怎么可能就读到一条），那就一定在mIds列表里，要么此时该事务还没生成，那么事务B插入的时候，该数据的事务版本必然是大于当前ReadView中的事务最大值的，不管是从那种情况来看根据ReadView的判别规则该数据都不可能读到。



[参考](https://www.jianshu.com/p/2953c64761aa)


















































